[{"/home/jack/dev/matula/chipper/src/index.tsx":"1","/home/jack/dev/matula/chipper/src/App.tsx":"2","/home/jack/dev/matula/chipper/src/example/ChipTwo.tsx":"3","/home/jack/dev/matula/chipper/src/example/ChipOne.tsx":"4","/home/jack/dev/matula/chipper/src/example/ChipDetached.tsx":"5","/home/jack/dev/matula/chipper/src/lib/index.ts":"6","/home/jack/dev/matula/chipper/src/example/Counter.ts":"7","/home/jack/dev/matula/chipper/src/lib/utils.ts":"8"},{"size":253,"mtime":1611342978961,"results":"9","hashOfConfig":"10"},{"size":665,"mtime":1611342782413,"results":"11","hashOfConfig":"10"},{"size":1572,"mtime":1611342529060,"results":"12","hashOfConfig":"10"},{"size":1530,"mtime":1611342523092,"results":"13","hashOfConfig":"10"},{"size":1574,"mtime":1611342507591,"results":"14","hashOfConfig":"10"},{"size":4821,"mtime":1611342664471,"results":"15","hashOfConfig":"10"},{"size":754,"mtime":1611287292671,"results":"16","hashOfConfig":"10"},{"size":2578,"mtime":1611342252254,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20","usedDeprecatedRules":"21"},"yd3q55",{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"30","messages":"31","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"21"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},"/home/jack/dev/matula/chipper/src/index.tsx",["38"],"import * as React from \"react\";\nimport ReactDOM, { render } from \"react-dom\";\n\nimport App from \"./App\";\n\n// const rootElement = document.getElementById(\"root\");\n// render(<App />, rootElement);\nReactDOM.render(<App />, document.getElementById(\"root\"));\n",["39","40"],"/home/jack/dev/matula/chipper/src/App.tsx",[],"/home/jack/dev/matula/chipper/src/example/ChipTwo.tsx",[],"/home/jack/dev/matula/chipper/src/example/ChipOne.tsx",[],"/home/jack/dev/matula/chipper/src/example/ChipDetached.tsx",[],"/home/jack/dev/matula/chipper/src/lib/index.ts",["41","42"],"import { Draft } from \"immer\";\nimport * as React from \"react\";\n\nimport * as Utils from \"./utils\";\n\nexport type IError = Error | string;\nexport type IStatus = {\n  type: \"LOADING\" | \"IDLE\" | \"SUCCESS\" | \"ERROR\";\n  message?: IError;\n};\nexport type IData = Record<string, unknown> | string;\nexport type IQue<T = IData> = { key: string; update: IUpdater<T> };\nexport type IQueue<T = IData> = [string, T][];\nexport type IUpdater<T = IData> = IChip<T> | ((chip: IChip<T>) => IChip<T>);\nexport interface IOptions<T = any> {\n  timeout?: number;\n  onInit?: () => void;\n  onSuccess?: (resp: T) => void;\n  onError?: (error: IError) => void;\n  wrapResp?: (...args: any[]) => T;\n}\nexport interface IChip<T = IData> {\n  data: T | undefined;\n  status: IStatus;\n}\nexport interface IQuery {\n  cut: (k?: string) => boolean;\n  get: (k?: string) => IChip;\n  set: <T>(chip: T | IChip<T>, k?: string) => void;\n}\nexport type IDraft<T = IData> = (data: Draft<T>) => void;\ntype ISet<T = IData> = T | IDraft<T>;\nexport type IUpdate<T = IData> = ISet<T> | Promise<T | void>;\ntype IDispatch<T = IData> = (chip: Draft<IChip<T>>) => IChip<T>;\n\nclass ChipperQueue {\n  queue: IQue[] = [];\n\n  enqueue(key: string, update: IUpdater) {\n    this.queue.push({ key, update });\n  }\n  dequeue(update: IUpdater) {\n    this.queue = this.queue.filter((chip) => update !== chip.update);\n  }\n  convey(key: string, chip: IChip) {\n    this.queue.forEach((convey) => {\n      if (key === convey.key) {\n        if (typeof convey.update === \"function\") convey.update(chip);\n        else convey.update = chip;\n      }\n    });\n  }\n}\n\nexport class ChipperConveyor extends ChipperQueue {\n  chips = new Map<string, IChip>();\n\n  createQueue(queue: IQueue) {\n    queue.map((que) => this.chips.set(que[0], Utils.newChip(que[1])));\n  }\n  queryQueue<T = IData>(key: string, data?: T) {\n    if (!this.chips.has(key)) this.chips.set(key, Utils.newChip(data));\n    return {\n      get: (k?: string) => this.chips.get(k || key),\n      cut: (k?: string) => this.chips.delete(k || key),\n      set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n        if (typeof data !== \"function\" && !(data instanceof Promise)) {\n          let chip = data as IChip;\n          if (chip.status === undefined) chip = Utils.newChip(data);\n          this.chips.set(k || key, chip);\n          this.convey(k || key, chip);\n        } else console.error(`Chipper: Promises and functions passed to api.set() are ignored`);\n      },\n    };\n  }\n}\n\nconst Chipper = new ChipperConveyor();\n\nfunction chipperOperator<T = IData>(chipper: ChipperConveyor, key: string, data?: T) {\n  const query = chipper.queryQueue(key, data);\n  const chip = query.get();\n  const [, dispatch] = React.useState(chip) as [never, IDispatch];\n  const isLoading = chip?.status?.type !== \"LOADING\";\n\n  React.useEffect(() => {\n    chipper.enqueue(key, dispatch);\n    return () => {\n      !isLoading && chipper.dequeue(dispatch);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return query as IQuery;\n}\n\nfunction chipperService<T = IData>(Query: IQuery, key: string) {\n  const chop = Query.get() as IChip;\n  const isLoading = chop?.status?.type === \"LOADING\";\n\n  async function set(update: IUpdate<T>, options?: IOptions<T>) {\n    if (!isLoading) {\n      const chip = Utils.chopper(chop, update);\n      if (update instanceof Promise) await Utils.setAsync<T>(Query, update, options);\n      else if (options?.timeout! > 0) {\n        const mocked = Utils.mockAsync<T>(chip.data as T, options?.timeout);\n        await Utils.setAsync<T>(Query, mocked, options);\n      } else {\n        const check = Utils.equalityCheck(chop.data, chip.data);\n        if (check === \"update\") Query.set(chip);\n        if (check === \"warn\") console.error(`Chipper: You're trying to change \"${key}\" data shape`);\n      }\n    }\n  }\n\n  const api = {\n    ...Query,\n    set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n      const chip = Query.get(k);\n      if (!chip) console.error(`Chipper: chip \"${k}\" doesn't exist`);\n      else if (chip.data) {\n        const check = Utils.equalityCheck(chip.data, data);\n        if (check === \"update\") Query.set(data, k || key);\n        if (check === \"warn\") {\n          console.error(`Chipper: You're trying to change \"${k || key}\" data shape`);\n        }\n      } else Query.set(data, k || key);\n    },\n  };\n\n  return { data: chop?.data, status: chop?.status, api, set };\n}\n\nexport function useChipper<T = IData>(instance: ChipperConveyor, key: string, data?: T) {\n  const Query = chipperOperator<T>(instance, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport function useChip<T = IData>(key: string, data?: T) {\n  const Query = chipperOperator<T>(Chipper, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport { Utils };\nexport default Chipper;\n","/home/jack/dev/matula/chipper/src/example/Counter.ts",[],"/home/jack/dev/matula/chipper/src/lib/utils.ts",[],["43","44"],{"ruleId":"45","severity":1,"message":"46","line":2,"column":20,"nodeType":"47","messageId":"48","endLine":2,"endColumn":26},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":2,"message":"54","line":83,"column":24,"nodeType":"55","endLine":83,"endColumn":38},{"ruleId":"53","severity":2,"message":"56","line":86,"column":3,"nodeType":"55","endLine":86,"endColumn":18},{"ruleId":"49","replacedBy":"57"},{"ruleId":"51","replacedBy":"58"},"@typescript-eslint/no-unused-vars","'render' is defined but never used.","Identifier","unusedVar","no-native-reassign",["59"],"no-negated-in-lhs",["60"],"react-hooks/rules-of-hooks","React Hook \"React.useState\" is called in function \"chipperOperator\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter.","MemberExpression","React Hook \"React.useEffect\" is called in function \"chipperOperator\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter.",["59"],["60"],"no-global-assign","no-unsafe-negation"]