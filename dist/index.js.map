{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import produce from 'immer';\n\nimport { IUpdate, IDraft, IData, IChip, IQuery, IOptions } from '.';\n\nexport function newChip<T = IData>(data: T) {\n  return { data, status: { type: 'IDLE' } } as IChip;\n}\n\nexport function equalityAction(chop: any, chip: any) {\n  if (!chop) return 'update'; // update if empty\n\n  const isObject = (o: any) => o && typeof o === 'object';\n  const objectKeys = (o: any) => (isObject(o) ? Object.keys(o) : [o]);\n  const isEqual = (chop: any, chip: any) => JSON.stringify(chop) === JSON.stringify(chip);\n  const chipKeys = objectKeys(chip);\n  const actions = [];\n\n  for (let key of chipKeys) {\n    const chipVal = chip[key];\n    const chopVal = chop[key];\n    const areValsEqual = isEqual(chopVal, chipVal);\n    const areTypesEqual = typeof chipVal === typeof chopVal;\n    const areValsKeysEqual = isEqual(objectKeys(chipVal), objectKeys(chopVal));\n    const areValsObjects = isObject(chipVal) && isObject(chopVal);\n\n    if (!chopVal) actions.push('update');\n    else if (areTypesEqual) {\n      if (!areValsEqual) {\n        if (!areValsKeysEqual) {\n          if (areValsObjects) actions.push('warn');\n          else actions.push('update');\n        } else actions.push(equalityAction(chopVal, chipVal));\n      } else actions.push('skip');\n    } else actions.push('warn');\n  }\n\n  if (actions.includes('warn')) return 'warn';\n  if (actions.includes('update')) return 'update';\n  return 'skip';\n}\n\nexport function chopper<T = IData>(chop: IChip, update: IUpdate<T>) {\n  let updated;\n  if (!chop.data) {\n    if (typeof update !== 'function') updated = produce(chop.data, () => update);\n    else updated = produce({}, update as IDraft);\n  } else if (typeof update !== 'function') updated = produce(chop.data, () => update);\n  else updated = produce(chop.data, update as IDraft);\n  return { ...chop, data: updated } as IChip;\n}\n\nexport function mockAsync<T = IData>(data: T, timeout?: number) {\n  return new Promise<T>((resolve, reject) => {\n    setTimeout(() => {\n      if (data !== undefined) resolve(data);\n      else reject({ message: 'Chipper: mockAsync() failed' });\n    }, timeout || 0);\n  });\n}\n\nexport async function setAsync<T = IData>(\n  Query: IQuery,\n  update: Promise<T | void>,\n  options?: IOptions<T>,\n) {\n  function initAsync() {\n    Query.set({ ...Query.get(), status: { type: 'LOADING' } });\n    return options?.onInit && options.onInit();\n  }\n  async function runAsync() {\n    try {\n      return await update;\n    } catch (error) {\n      return error;\n    }\n  }\n  function failAsync(message: string) {\n    Query.set({ ...Query.get(), status: { type: 'ERROR', message } });\n    return options?.onError && options.onError(message);\n  }\n  function finishAsync(resp: T) {\n    const data = options?.wrapResp ? options.wrapResp(resp) : resp;\n    Query.set({ data, status: { type: 'SUCCESS' } });\n    return options?.onSuccess && options.onSuccess(data);\n  }\n\n  async function* createAsyncGenerator() {\n    yield initAsync();\n    const resp = await runAsync();\n    yield await resp;\n    if (resp instanceof Error) return failAsync(resp.message);\n    else return finishAsync(resp);\n  }\n\n  const AsyncGenerator = createAsyncGenerator();\n  AsyncGenerator.next();\n  await AsyncGenerator.next();\n  AsyncGenerator.next();\n}\n","import { Draft } from 'immer';\nimport * as React from 'react';\n\nimport * as Utils from './utils';\n\nexport type IError = Error | string;\nexport type IStatus = {\n  type: 'LOADING' | 'IDLE' | 'SUCCESS' | 'ERROR';\n  message?: IError;\n};\nexport type IData = Record<string, unknown> | string | null | number;\nexport type IQue<T = IData> = { key: string; update: IUpdater<T> };\nexport type IQueue<T = IData> = [string, T | null][];\nexport type IUpdater<T = IData> = IChip<T> | ((chip: IChip<T>) => IChip<T>);\nexport interface IOptions<T = any> {\n  timeout?: number;\n  onInit?: () => void;\n  onSuccess?: (resp: T) => void;\n  onError?: (error: IError) => void;\n  wrapResp?: (...args: any[]) => T;\n}\nexport interface IChip<T = IData> {\n  data: T | undefined;\n  status: IStatus;\n}\nexport interface IQuery {\n  cut: (k?: string) => boolean;\n  get: (k?: string) => IChip;\n  set: <T>(chip: T | IChip<T>, k?: string) => void;\n}\nexport type IDraft<T = IData> = (data: Draft<T>) => void;\nexport type ISet<T = IData> = T | IDraft<T>;\nexport type IUpdate<T = IData> = ISet<T> | Promise<T | void>;\nexport type IDispatch<T = IData> = (chip: Draft<IChip<T>>) => IChip<T>;\n\nclass ChipperQueue {\n  queue: IQue[] = [];\n\n  enqueue(key: string, update: IUpdater) {\n    this.queue.push({ key, update });\n  }\n  dequeue(update: IUpdater) {\n    this.queue = this.queue.filter((chip) => update !== chip.update);\n  }\n  convey(key: string, chip: IChip) {\n    this.queue.forEach((convey) => {\n      if (key === convey.key) {\n        if (typeof convey.update === 'function') convey.update(chip);\n        else convey.update = chip;\n      }\n    });\n  }\n}\n\nexport class ChipperConveyor extends ChipperQueue {\n  chips = new Map<string, IChip>();\n\n  createQueue(queue: IQueue) {\n    queue.map((que) => this.chips.set(que[0], Utils.newChip(que[1])));\n  }\n  queryQueue<T = IData>(key: string, data?: T) {\n    if (!this.chips.has(key)) this.chips.set(key, Utils.newChip(data));\n    return {\n      get: (k?: string) => this.chips.get(k || key),\n      cut: (k?: string) => this.chips.delete(k || key),\n      set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n        if (typeof data !== 'function' && !(data instanceof Promise)) {\n          let chip = data as IChip;\n          if (chip.status === undefined) chip = Utils.newChip(data);\n          this.chips.set(k || key, chip);\n          this.convey(k || key, chip);\n        } else console.error(`Chipper: Promises and functions passed to api.set() are ignored`);\n      },\n    };\n  }\n}\n\nconst Chipper = new ChipperConveyor();\n\nfunction chipperOperator<T = IData>(chipper: ChipperConveyor, key: string, data?: T) {\n  const query = chipper.queryQueue(key, data);\n  const chip = query.get();\n  const [, dispatch] = React.useState(chip) as [never, IDispatch];\n  const isLoading = chip?.status?.type !== 'LOADING';\n\n  React.useEffect(() => {\n    chipper.enqueue(key, dispatch);\n    return () => {\n      !isLoading && chipper.dequeue(dispatch);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return query as IQuery;\n}\n\nfunction chipperService<T = IData>(Query: IQuery, key: string) {\n  const chop = Query.get() as IChip;\n  const isLoading = chop?.status?.type === 'LOADING';\n\n  async function set(update: IUpdate<T>, options?: IOptions<T>) {\n    if (!isLoading) {\n      const chip = Utils.chopper(chop, update);\n      if (update instanceof Promise) await Utils.setAsync<T>(Query, update, options);\n      else if (options?.timeout! > 0) {\n        const mocked = Utils.mockAsync<T>(chip.data as T, options?.timeout);\n        await Utils.setAsync<T>(Query, mocked, options);\n      } else {\n        const check = Utils.equalityAction(chop.data, chip.data);\n        if (check === 'update') Query.set(chip);\n        if (check === 'warn') console.error(`Chipper: You're trying to change \"${key}\" data shape`);\n      }\n    }\n  }\n\n  const api = {\n    ...Query,\n    set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n      const chip = Query.get(k);\n      if (!chip) console.error(`Chipper: chip \"${k}\" doesn't exist`);\n      else if (chip.data) {\n        const check = Utils.equalityAction(chip.data, data);\n        if (check === 'update') Query.set(data, k || key);\n        if (check === 'warn') {\n          console.error(`Chipper: You're trying to change \"${k || key}\" data shape`);\n        }\n      } else Query.set(data, k || key);\n    },\n  };\n\n  return { data: chop?.data, status: chop?.status, api, set };\n}\n\nexport function useChipper<T = IData>(instance: ChipperConveyor, key: string, data?: T) {\n  const Query = chipperOperator<T>(instance, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport function useChip<T = IData>(key: string, data?: T) {\n  const Query = chipperOperator<T>(Chipper, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport { Utils };\nexport default Chipper;\n"],"names":["newChip","data","status","type","equalityAction","chop","chip","isObject","o","objectKeys","Object","keys","isEqual","JSON","stringify","chipKeys","actions","chipKeys_1","__values","key","chipVal","chopVal","areValsEqual","areTypesEqual","areValsKeysEqual","areValsObjects","push","includes","chopper","update","updated","produce","__assign","mockAsync","timeout","Promise","resolve","reject","setTimeout","undefined","message","setAsync","Query","options","createAsyncGenerator","set","get","onInit","_a","runAsync","resp","Error","onError","wrapResp","onSuccess","AsyncGenerator","next","this","ChipperQueue","queue","filter","forEach","convey","_this","Map","__extends","ChipperConveyor","map","que","chips","Utils.newChip","has","k","cut","delete","console","error","Chipper","chipperOperator","chipper","query","queryQueue","dispatch","__read","React.useState","isLoading","React.useEffect","enqueue","dequeue","chipperService","api","check","Utils.equalityAction","Utils.chopper","Utils.setAsync","mocked","Utils.mockAsync","useChipper","instance","useChip"],"mappings":"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"}