{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import produce from 'immer';\n\nimport { IUpdate, IDraft, IData, IChip, IQuery, IOptions } from '.';\n\nexport function newChip<T = IData>(data: T) {\n  return { data, status: { type: 'IDLE' } } as IChip;\n}\n\n// look at this magnificent example of spaghetti machine learning! ;)\nexport function equalityAction(chop: any, chip: any) {\n  const isEqual = (chop: any, chip: any) => JSON.stringify(chop) === JSON.stringify(chip);\n\n  if (isEqual(chop, chip)) return 'skip';\n  if (chop === null && typeof chip === 'undefined') return 'warn';\n  if (chop === null || typeof chop === 'undefined') return 'update';\n\n  const isObject = (o: any) => o && typeof o === 'object';\n  const areTypesEqual = (a: any, b: any) => typeof a === typeof b;\n\n  if (!isObject(chop)) {\n    if (areTypesEqual(chop, chip)) {\n      if (isEqual(chop, chip)) return 'skip';\n      return 'update';\n    } else {\n      if (chip === null) return 'update';\n      return 'warn';\n    }\n  }\n\n  const objectKeys = (o: any) => (isObject(o) ? Object.keys(o) : [o]);\n  const chopKeys = objectKeys(chop);\n\n  const actions = [];\n  for (let key of chopKeys) {\n    const chopVal = chop[key];\n    const chipVal = chip[key];\n    const isArray = (o: any) => Array.isArray(o);\n    const areValsEqual = isEqual(chopVal, chipVal);\n    const areValsKeysEqual = isEqual(objectKeys(chipVal), objectKeys(chopVal));\n    const areValsArrays = isArray(chipVal) && isArray(chopVal);\n    const areValsObjects = isObject(chipVal) && isObject(chopVal);\n\n    if (areTypesEqual(chopVal, chipVal)) {\n      if (!areValsEqual) {\n        if (!areValsKeysEqual) {\n          if (areValsArrays) actions.push('update');\n          else if (isArray(chopVal) && !isArray(chipVal)) {\n            if (chipVal === null) actions.push('update');\n            else actions.push('warn');\n          } else if (!isArray(chopVal) && isArray(chipVal)) actions.push('warn');\n          else if (areValsObjects) actions.push(equalityAction(chopVal, chipVal));\n          else actions.push('update');\n        } else actions.push(equalityAction(chopVal, chipVal));\n      } else {\n        if (areTypesEqual(chopVal, chipVal)) actions.push('update');\n        else actions.push('skip');\n      }\n    } else {\n      if (chipVal === null) actions.push('update');\n      else actions.push('warn');\n    }\n  }\n\n  if (actions.includes('warn')) return 'warn';\n  if (actions.includes('update')) return 'update';\n  return 'skip';\n}\n\nexport function chopper<T = IData>(chop: IChip, update: IUpdate<T>) {\n  let updated;\n  if (!chop.data) {\n    if (typeof update !== 'function') updated = produce(chop.data, () => update);\n    else updated = produce({}, update as IDraft);\n  } else if (typeof update !== 'function') updated = produce(chop.data, () => update);\n  else updated = produce(chop.data, update as IDraft);\n  return { ...chop, data: updated } as IChip;\n}\n\nexport function mockAsync<T = IData>(data: T, timeout?: number) {\n  return new Promise<T>((resolve, reject) => {\n    setTimeout(() => {\n      if (data !== undefined) resolve(data);\n      else reject({ message: 'Chipper: mockAsync() failed' });\n    }, timeout || 0);\n  });\n}\n\nexport async function setAsync<T = IData>(\n  Query: IQuery,\n  update: Promise<T | void>,\n  options?: IOptions<T>,\n) {\n  function initAsync() {\n    Query.set({ ...Query.get(), status: { type: 'LOADING' } });\n    return options?.onInit && options.onInit();\n  }\n  async function runAsync() {\n    try {\n      return await update;\n    } catch (error) {\n      return error;\n    }\n  }\n  function failAsync(message: string) {\n    Query.set({ ...Query.get(), status: { type: 'ERROR', message } });\n    console.error(message);\n    return options?.onError && options.onError(message);\n  }\n  function finishAsync(resp: T) {\n    const data = options?.wrapResp ? options.wrapResp(resp) : resp;\n    const check = equalityAction(Query.get().data, data);\n    if (check === 'update') {\n      Query.set({ data, status: { type: 'SUCCESS' } });\n      return options?.onSuccess && options.onSuccess(data);\n    } else if (check === 'warn') failAsync(`Chipper: You're trying to change data shape`);\n    else failAsync(`Chipper: Update was skipped due to equal datasets`);\n  }\n\n  async function* createAsyncGenerator() {\n    yield initAsync();\n    const resp = await runAsync();\n    yield await resp;\n    if (resp instanceof Error) return failAsync(resp.message);\n    else return finishAsync(resp);\n  }\n\n  const AsyncGenerator = createAsyncGenerator();\n  AsyncGenerator.next();\n  await AsyncGenerator.next();\n  AsyncGenerator.next();\n}\n","import { Draft } from 'immer';\nimport * as React from 'react';\n\nimport * as Utils from './utils';\n\nexport type IError = Error | string;\nexport type IStatus = {\n  type: 'LOADING' | 'IDLE' | 'SUCCESS' | 'ERROR';\n  message?: IError;\n};\nexport type IData = Record<string, unknown> | string | null | number;\nexport type IQue<T = IData> = { key: string; update: IUpdater<T> };\nexport type IQueue<T = IData> = [string, T | null][];\nexport type IUpdater<T = IData> = IChip<T> | ((chip: IChip<T>) => IChip<T>);\nexport interface IOptions<T = any> {\n  timeout?: number;\n  onInit?: () => void;\n  onSuccess?: (resp: T) => void;\n  onError?: (error: IError) => void;\n  wrapResp?: (...args: any[]) => T;\n}\nexport interface IChip<T = IData> {\n  data: T | undefined;\n  status: IStatus;\n}\nexport interface IQuery {\n  cut: (k?: string) => boolean;\n  get: (k?: string) => IChip;\n  set: <T>(chip: T | IChip<T>, k?: string) => void;\n}\nexport type IDraft<T = IData> = (data: Draft<T>) => void;\nexport type ISet<T = IData> = T | IDraft<T>;\nexport type IUpdate<T = IData> = ISet<T> | Promise<T | void>;\nexport type IDispatch<T = IData> = (chip: Draft<IChip<T>>) => IChip<T>;\n\nclass ChipperQueue {\n  queue: IQue[] = [];\n\n  enqueue(key: string, update: IUpdater) {\n    this.queue.push({ key, update });\n  }\n  dequeue(update: IUpdater) {\n    this.queue = this.queue.filter((chip) => update !== chip.update);\n  }\n  convey(key: string, chip: IChip) {\n    this.queue.forEach((convey) => {\n      if (key === convey.key) {\n        if (typeof convey.update === 'function') convey.update(chip);\n        else convey.update = chip;\n      }\n    });\n  }\n}\n\nexport class ChipperConveyor extends ChipperQueue {\n  chips = new Map<string, IChip>();\n\n  createQueue(queue: IQueue) {\n    queue.map((que) => this.chips.set(que[0], Utils.newChip(que[1])));\n  }\n  queryQueue<T = IData>(key: string, data?: T) {\n    if (!this.chips.has(key)) this.chips.set(key, Utils.newChip(data));\n    return {\n      get: (k?: string) => this.chips.get(k || key),\n      cut: (k?: string) => this.chips.delete(k || key),\n      set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n        if (typeof data !== 'function' && !(data instanceof Promise)) {\n          let chip = data as IChip;\n          if (chip.status === undefined) chip = Utils.newChip(data);\n          this.chips.set(k || key, chip);\n          this.convey(k || key, chip);\n        } else console.error(`Chipper: Promises and functions passed to api.set() are ignored`);\n      },\n    };\n  }\n}\n\nconst Chipper = new ChipperConveyor();\n\nfunction chipperOperator<T = IData>(chipper: ChipperConveyor, key: string, data?: T) {\n  const query = chipper.queryQueue(key, data);\n  const chip = query.get();\n  const [, dispatch] = React.useState(chip) as [never, IDispatch];\n  const isLoading = chip?.status?.type !== 'LOADING';\n\n  React.useEffect(() => {\n    chipper.enqueue(key, dispatch);\n    return () => {\n      !isLoading && chipper.dequeue(dispatch);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return query as IQuery;\n}\n\nfunction chipperService<T = IData>(Query: IQuery, key: string) {\n  const chop = Query.get() as IChip;\n  const isLoading = chop?.status?.type === 'LOADING';\n\n  async function set(update: IUpdate<T>, options?: IOptions<T>) {\n    if (!isLoading) {\n      const chip = Utils.chopper(chop, update);\n      if (update instanceof Promise) await Utils.setAsync<T>(Query, update, options);\n      else if (options?.timeout! > 0) {\n        const mocked = Utils.mockAsync<T>(chip.data as T, options?.timeout);\n        await Utils.setAsync<T>(Query, mocked, options);\n      } else {\n        const check = Utils.equalityAction(chop.data, chip.data);\n        if (check === 'update') Query.set(chip);\n        if (check === 'warn') console.error(`Chipper: You're trying to change \"${key}\" data shape`);\n      }\n    }\n  }\n\n  const api = {\n    ...Query,\n    set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n      const chip = Query.get(k);\n      if (!chip) console.error(`Chipper: chip \"${k}\" doesn't exist`);\n      else if (chip.data) {\n        const check = Utils.equalityAction(chip.data, data);\n        if (check === 'update') Query.set(data, k || key);\n        if (check === 'warn') {\n          console.error(`Chipper: You're trying to change \"${k || key}\" data shape`);\n        }\n      } else Query.set(data, k || key);\n    },\n  };\n\n  return { data: chop?.data, status: chop?.status, api, set };\n}\n\nexport function useChipper<T = IData>(instance: ChipperConveyor, key: string, data?: T) {\n  const Query = chipperOperator<T>(instance, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport function useChip<T = IData>(key: string, data?: T) {\n  const Query = chipperOperator<T>(Chipper, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport { Utils };\nexport default Chipper;\n"],"names":["newChip","data","status","type","equalityAction","chop","chip","isEqual","JSON","stringify","isObject","o","areTypesEqual","a","b","objectKeys","Object","keys","chopKeys","actions","chopKeys_1","__values","isArray","Array","key","chopVal","chipVal","areValsEqual","areValsKeysEqual","areValsArrays","areValsObjects","push","includes","chopper","update","updated","produce","__assign","mockAsync","timeout","Promise","resolve","reject","setTimeout","undefined","message","setAsync","Query","options","failAsync","set","get","console","error","onError","createAsyncGenerator","onInit","_a","runAsync","resp","Error","wrapResp","check","onSuccess","finishAsync","AsyncGenerator","next","this","ChipperQueue","queue","filter","forEach","convey","_this","Map","__extends","ChipperConveyor","map","que","chips","Utils.newChip","has","k","cut","delete","Chipper","chipperOperator","chipper","query","queryQueue","dispatch","__read","React.useState","isLoading","React.useEffect","enqueue","dequeue","chipperService","api","Utils.equalityAction","Utils.chopper","Utils.setAsync","mocked","Utils.mockAsync","useChipper","instance","useChip"],"mappings":"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"}