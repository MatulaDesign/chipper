{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import produce from 'immer';\n\nimport { IUpdate, IDraft, IData, IChip, IQuery, IOptions } from '.';\n\nexport function newChip<T = IData>(data: T) {\n  return { data, status: { type: 'IDLE' } } as IChip;\n}\n\n// look at this magnificent example of spaghetti machine learning! ;)\nexport function equalityAction(chop: any, chip: any) {\n  const isEqual = (chop: any, chip: any) => JSON.stringify(chop) === JSON.stringify(chip);\n\n  if (isEqual(chop, chip)) return 'skip';\n  if (chop === null && typeof chip === 'undefined') return 'warn';\n  if (chop === null || typeof chop === 'undefined') return 'update';\n\n  const isObject = (o: any) => o && typeof o === 'object';\n  const areTypesEqual = (a: any, b: any) => typeof a === typeof b;\n\n  if (!isObject(chop)) {\n    if (areTypesEqual(chop, chip)) {\n      return isEqual(chop, chip) ? 'skip' : 'update';\n    } else return chip === null ? 'update' : 'warn';\n  }\n\n  const objectKeys = (o: any) => (isObject(o) ? Object.keys(o) : [o]);\n  const chopKeys = objectKeys(chop);\n\n  const actions = [];\n  for (let key of chopKeys) {\n    const chopVal = chop[key];\n    const chipVal = chip[key];\n    const isArray = (o: any) => Array.isArray(o);\n    const areValsEqual = isEqual(chopVal, chipVal);\n    const areValsKeysEqual = isEqual(objectKeys(chipVal), objectKeys(chopVal));\n    const areValsArrays = isArray(chipVal) && isArray(chopVal);\n    const areValsObjects = isObject(chipVal) && isObject(chopVal);\n\n    if (areTypesEqual(chopVal, chipVal)) {\n      if (!areValsEqual) {\n        if (!areValsKeysEqual) {\n          if (areValsArrays) actions.push('update');\n          else if (isArray(chopVal) && !isArray(chipVal)) {\n            if (chipVal === null) actions.push('update');\n            else actions.push('warn');\n          } else if (!isArray(chopVal) && isArray(chipVal)) actions.push('warn');\n          else if (areValsObjects) actions.push(equalityAction(chopVal, chipVal));\n          else actions.push('update');\n        } else actions.push(equalityAction(chopVal, chipVal));\n      } else {\n        if (areTypesEqual(chopVal, chipVal)) actions.push('update');\n        else actions.push('skip');\n      }\n    } else {\n      if (chipVal === null) actions.push('update');\n      else actions.push('warn');\n    }\n  }\n\n  if (actions.includes('warn')) return 'warn';\n  if (actions.includes('update')) return 'update';\n  return 'skip';\n}\n\nexport function chopper<T = IData>(chop: IChip, update: IUpdate<T>) {\n  let updated;\n  if (!chop.data) {\n    if (typeof update !== 'function') updated = produce(chop.data, () => update);\n    else updated = produce({}, update as IDraft);\n  } else if (typeof update !== 'function') updated = produce(chop.data, () => update);\n  else updated = produce(chop.data, update as IDraft);\n  return { ...chop, data: updated } as IChip;\n}\n\nexport function mockAsync<T = IData>(data: T, timeout?: number) {\n  return new Promise<T>((resolve, reject) => {\n    setTimeout(() => {\n      if (data !== undefined) resolve(data);\n      else reject({ message: 'Chipper: mockAsync() failed' });\n    }, timeout || 0);\n  });\n}\n\nexport async function setAsync<T = IData>(\n  Query: IQuery,\n  update: Promise<T | void>,\n  options?: IOptions<T>,\n) {\n  function initAsync() {\n    Query.set({ ...Query.get(), status: { type: 'LOADING' } });\n    return options?.onInit && options.onInit();\n  }\n  async function runAsync() {\n    try {\n      return await update;\n    } catch (error) {\n      return error;\n    }\n  }\n  function failAsync(message: string) {\n    Query.set({ ...Query.get(), status: { type: 'ERROR', message } });\n    return options?.onError && options.onError(message);\n  }\n  function finishAsync(resp: T) {\n    const data = options?.wrapResp ? options.wrapResp(resp) : resp;\n    const check = equalityAction(Query.get().data, data);\n    if (check === 'update') {\n      Query.set({ data, status: { type: 'SUCCESS' } });\n      return options?.onSuccess && options.onSuccess(data);\n    } else if (check === 'warn') console.warn(`ChipperAsync: You're trying to change data shape`);\n    else console.warn(`ChipperAsync: Update was skipped due to equal datasets`);\n  }\n\n  async function* createAsyncGenerator() {\n    yield initAsync();\n    const resp = await runAsync();\n    yield await resp;\n    if (resp instanceof Error) return failAsync(resp.message);\n    else return finishAsync(resp);\n  }\n\n  const AsyncGenerator = createAsyncGenerator();\n  AsyncGenerator.next();\n  await AsyncGenerator.next();\n  AsyncGenerator.next();\n}\n","import { Draft } from 'immer';\nimport * as React from 'react';\n\nimport * as Utils from './utils';\n\nexport type IError = Error | string;\nexport type IStatus = {\n  type: 'LOADING' | 'IDLE' | 'SUCCESS' | 'ERROR';\n  message?: IError;\n};\nexport type IData = Record<string, unknown> | string | null | number | any;\nexport type IQue<T = IData> = { key: string; update: IUpdater<T> };\nexport type IQueue<T = IData> = [string, T | null][];\nexport type IUpdater<T = IData> = IChip<T> | ((chip: IChip<T>) => IChip<T>);\nexport interface IOptions<T = any> {\n  timeout?: number;\n  onInit?: () => void;\n  onSuccess?: (resp: T) => void;\n  onError?: (error: IError) => void;\n  wrapResp?: (...args: any[]) => T;\n}\nexport interface IChip<T = IData> {\n  data: T | undefined;\n  status: IStatus;\n}\nexport interface IQuery {\n  cut: (k?: string) => boolean;\n  get: (k?: string) => IChip;\n  set: <T>(chip: T | IChip<T>, k?: string) => void;\n}\nexport type IDraft<T = IData> = (data: Draft<T>) => void;\nexport type ISet<T = IData> = T | IDraft<T>;\nexport type IUpdate<T = IData> = ISet<T> | Promise<T | void>;\nexport type IDispatch<T = IData> = (chip: Draft<IChip<T>>) => IChip<T>;\n\nclass ChipperQueue {\n  queue: IQue[] = [];\n\n  enqueue(key: string, update: IUpdater) {\n    this.queue.push({ key, update });\n  }\n  dequeue(update: IUpdater) {\n    this.queue = this.queue.filter((chip) => update !== chip.update);\n  }\n  convey(key: string, chip: IChip) {\n    this.queue.forEach((convey) => {\n      if (key === convey.key) {\n        if (typeof convey.update === 'function') convey.update(chip);\n        else convey.update = chip;\n      }\n    });\n  }\n}\n\nexport class ChipperConveyor extends ChipperQueue {\n  chips = new Map<string, IChip>();\n\n  loadChips(queue: IQueue) {\n    queue.map((que) => this.chips.set(que[0], Utils.newChip(que[1])));\n  }\n  queryChips<T = IData>(key: string, data?: T) {\n    if (!this.chips.has(key)) this.chips.set(key, Utils.newChip(data));\n    return {\n      get: (k?: string) => this.chips.get(k || key),\n      cut: (k?: string) => this.chips.delete(k || key),\n      set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n        if (typeof data !== 'function' && !(data instanceof Promise)) {\n          let chip = data as IChip;\n          if (chip.status === undefined) chip = Utils.newChip(data);\n          this.chips.set(k || key, chip);\n          this.convey(k || key, chip);\n        } else console.error(`Chipper: Promises and functions passed to api.set() are ignored`);\n      },\n    };\n  }\n}\n\nconst Chipper = new ChipperConveyor();\n\nfunction ChipperOperator<T = IData>(chipper: ChipperConveyor, key: string, data?: T) {\n  const query = chipper.queryChips(key, data);\n  const chip = query.get();\n  const [, dispatch] = React.useState(chip) as [never, IDispatch];\n  const isLoading = chip?.status?.type !== 'LOADING';\n\n  React.useEffect(() => {\n    chipper.enqueue(key, dispatch);\n    return () => {\n      !isLoading && chipper.dequeue(dispatch);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return query as IQuery;\n}\n\nfunction ChipperService<T = IData>(Query: IQuery, key: string) {\n  const chop = Query.get() as IChip;\n  const isLoading = chop?.status?.type === 'LOADING';\n\n  async function set(update: IUpdate<T>, options?: IOptions<T>) {\n    if (!isLoading) {\n      const chip = Utils.chopper(chop, update);\n      if (update instanceof Promise) await Utils.setAsync<T>(Query, update, options);\n      else if (options?.timeout! > 0) {\n        const mocked = Utils.mockAsync<T>(chip.data as T, options?.timeout);\n        await Utils.setAsync<T>(Query, mocked, options);\n      } else {\n        const check = Utils.equalityAction(chop.data, chip.data);\n        if (check === 'update') Query.set(chip);\n        if (check === 'warn') console.error(`Chipper: You're trying to change \"${key}\" data shape`);\n      }\n    }\n  }\n\n  const api = {\n    ...Query,\n    set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n      const chip = Query.get(k);\n      if (!chip) console.error(`Chipper: chip \"${k}\" doesn't exist`);\n      else if (chip.data) {\n        const check = Utils.equalityAction(chip.data, data);\n        if (check === 'update') Query.set(data, k || key);\n        if (check === 'warn') {\n          console.error(`Chipper: You're trying to change \"${k || key}\" data shape`);\n        }\n      } else Query.set(data, k || key);\n    },\n  };\n\n  return { data: chop?.data, status: chop?.status, api, set };\n}\n\nexport function useChipper<T = IData>(instance: ChipperConveyor, key: string, data?: T) {\n  const Query = ChipperOperator<T>(instance, key, data) as IQuery;\n  return ChipperService<T>(Query, key);\n}\n\nexport function useChip<T = IData>(key: string, data?: T) {\n  const Query = ChipperOperator<T>(Chipper, key, data) as IQuery;\n  return ChipperService<T>(Query, key);\n}\n\nexport { Utils };\nexport default Chipper;\n"],"names":["newChip","data","status","type","equalityAction","chop","chip","isEqual","JSON","stringify","isObject","o","areTypesEqual","a","b","objectKeys","Object","keys","chopKeys","actions","chopKeys_1","__values","isArray","Array","key","chopVal","chipVal","areValsEqual","areValsKeysEqual","areValsArrays","areValsObjects","push","includes","chopper","update","updated","produce","__assign","mockAsync","timeout","Promise","resolve","reject","setTimeout","undefined","message","setAsync","Query","options","createAsyncGenerator","set","get","onInit","_a","runAsync","resp","Error","onError","wrapResp","check","onSuccess","console","warn","finishAsync","AsyncGenerator","next","this","ChipperQueue","queue","filter","forEach","convey","_this","Map","__extends","ChipperConveyor","map","que","chips","Utils.newChip","has","k","cut","delete","error","Chipper","ChipperOperator","chipper","query","queryChips","dispatch","__read","React.useState","isLoading","React.useEffect","enqueue","dequeue","ChipperService","api","Utils.equalityAction","Utils.chopper","Utils.setAsync","mocked","Utils.mockAsync","useChipper","instance","useChip"],"mappings":"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"}