{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import produce from 'immer';\n\nimport { IUpdate, IDraft, IData, IChip, IQuery, IOptions } from '.';\n\nexport function newChip<T = IData>(data: T) {\n  return { data, status: { type: 'IDLE' } } as IChip;\n}\n\nexport function equalityCheck(chop: any, chip: any) {\n  const isObject = (v: IData) => typeof v === 'object';\n  const objectKeys = (o: IData) => (isObject(o) ? Object.keys(o!).sort() : []);\n  const isEqual = (chop: any, chip: any) => JSON.stringify(chop) === JSON.stringify(chip);\n\n  if (!chop) return 'update'; // update if empty\n  // check if objects have same keys\n  if (isEqual(objectKeys(chop), objectKeys(chip))) {\n    // check if objects are equal\n    if (isEqual(chop, chip)) return 'skip';\n    return 'update';\n  } else return 'warn';\n}\n\nexport function chopper<T = IData>(chop: IChip, update: IUpdate<T>) {\n  let updated;\n  if (!chop.data) {\n    if (typeof update !== 'function') updated = produce(chop.data, () => update);\n    else updated = produce({}, update as IDraft);\n  } else if (typeof update !== 'function') updated = produce(chop.data, () => update);\n  else updated = produce(chop.data, update as IDraft);\n  return { ...chop, data: updated } as IChip;\n}\n\nexport function mockAsync<T = IData>(data: T, timeout?: number) {\n  return new Promise<T>((resolve, reject) => {\n    setTimeout(() => {\n      if (data !== undefined) resolve(data);\n      else reject({ message: 'Chipper: mockAsync() failed' });\n    }, timeout || 0);\n  });\n}\n\nexport async function setAsync<T = IData>(\n  Query: IQuery,\n  update: Promise<T | void>,\n  options?: IOptions<T>,\n) {\n  function initAsync() {\n    Query.set({ ...Query.get(), status: { type: 'LOADING' } });\n    return options?.onInit && options.onInit();\n  }\n  async function runAsync() {\n    try {\n      return await update;\n    } catch (error) {\n      return error;\n    }\n  }\n  function failAsync(message: string) {\n    Query.set({ ...Query.get(), status: { type: 'ERROR', message } });\n    return options?.onError && options.onError(message);\n  }\n  function finishAsync(resp: T) {\n    const data = options?.wrapResp ? options.wrapResp(resp) : resp;\n    Query.set({ data, status: { type: 'SUCCESS' } });\n    return options?.onSuccess && options.onSuccess(data);\n  }\n\n  async function* createAsyncGenerator() {\n    yield initAsync();\n    const resp = await runAsync();\n    yield await resp;\n    if (resp instanceof Error) return failAsync(resp.message);\n    else return finishAsync(resp);\n  }\n\n  const AsyncGenerator = createAsyncGenerator();\n  AsyncGenerator.next();\n  await AsyncGenerator.next();\n  AsyncGenerator.next();\n}\n","import { Draft } from 'immer';\nimport * as React from 'react';\n\nimport * as Utils from './utils';\n\nexport type IError = Error | string;\nexport type IStatus = {\n  type: 'LOADING' | 'IDLE' | 'SUCCESS' | 'ERROR';\n  message?: IError;\n};\nexport type IData = Record<string, unknown> | string | null | number;\nexport type IQue<T = IData> = { key: string; update: IUpdater<T> };\nexport type IQueue<T = IData> = [string, T][];\nexport type IUpdater<T = IData> = IChip<T> | ((chip: IChip<T>) => IChip<T>);\nexport interface IOptions<T = any> {\n  timeout?: number;\n  onInit?: () => void;\n  onSuccess?: (resp: T) => void;\n  onError?: (error: IError) => void;\n  wrapResp?: (...args: any[]) => T;\n}\nexport interface IChip<T = IData> {\n  data: T | undefined;\n  status: IStatus;\n}\nexport interface IQuery {\n  cut: (k?: string) => boolean;\n  get: (k?: string) => IChip;\n  set: <T>(chip: T | IChip<T>, k?: string) => void;\n}\nexport type IDraft<T = IData> = (data: Draft<T>) => void;\nexport type ISet<T = IData> = T | IDraft<T>;\nexport type IUpdate<T = IData> = ISet<T> | Promise<T | void>;\nexport type IDispatch<T = IData> = (chip: Draft<IChip<T>>) => IChip<T>;\n\nclass ChipperQueue {\n  queue: IQue[] = [];\n\n  enqueue(key: string, update: IUpdater) {\n    this.queue.push({ key, update });\n  }\n  dequeue(update: IUpdater) {\n    this.queue = this.queue.filter((chip) => update !== chip.update);\n  }\n  convey(key: string, chip: IChip) {\n    this.queue.forEach((convey) => {\n      if (key === convey.key) {\n        if (typeof convey.update === 'function') convey.update(chip);\n        else convey.update = chip;\n      }\n    });\n  }\n}\n\nexport class ChipperConveyor extends ChipperQueue {\n  chips = new Map<string, IChip>();\n\n  createQueue(queue: IQueue) {\n    queue.map((que) => this.chips.set(que[0], Utils.newChip(que[1])));\n  }\n  queryQueue<T = IData>(key: string, data?: T) {\n    if (!this.chips.has(key)) this.chips.set(key, Utils.newChip(data));\n    return {\n      get: (k?: string) => this.chips.get(k || key),\n      cut: (k?: string) => this.chips.delete(k || key),\n      set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n        if (typeof data !== 'function' && !(data instanceof Promise)) {\n          let chip = data as IChip;\n          if (chip.status === undefined) chip = Utils.newChip(data);\n          this.chips.set(k || key, chip);\n          this.convey(k || key, chip);\n        } else console.error(`Chipper: Promises and functions passed to api.set() are ignored`);\n      },\n    };\n  }\n}\n\nconst Chipper = new ChipperConveyor();\n\nfunction chipperOperator<T = IData>(chipper: ChipperConveyor, key: string, data?: T) {\n  const query = chipper.queryQueue(key, data);\n  const chip = query.get();\n  const [, dispatch] = React.useState(chip) as [never, IDispatch];\n  const isLoading = chip?.status?.type !== 'LOADING';\n\n  React.useEffect(() => {\n    chipper.enqueue(key, dispatch);\n    return () => {\n      !isLoading && chipper.dequeue(dispatch);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return query as IQuery;\n}\n\nfunction chipperService<T = IData>(Query: IQuery, key: string) {\n  const chop = Query.get() as IChip;\n  const isLoading = chop?.status?.type === 'LOADING';\n\n  async function set(update: IUpdate<T>, options?: IOptions<T>) {\n    if (!isLoading) {\n      const chip = Utils.chopper(chop, update);\n      if (update instanceof Promise) await Utils.setAsync<T>(Query, update, options);\n      else if (options?.timeout! > 0) {\n        const mocked = Utils.mockAsync<T>(chip.data as T, options?.timeout);\n        await Utils.setAsync<T>(Query, mocked, options);\n      } else {\n        const check = Utils.equalityCheck(chop.data, chip.data);\n        if (check === 'update') Query.set(chip);\n        if (check === 'warn') console.error(`Chipper: You're trying to change \"${key}\" data shape`);\n      }\n    }\n  }\n\n  const api = {\n    ...Query,\n    set: <R = T & IData>(data: R | IChip<R>, k?: string) => {\n      const chip = Query.get(k);\n      if (!chip) console.error(`Chipper: chip \"${k}\" doesn't exist`);\n      else if (chip.data) {\n        const check = Utils.equalityCheck(chip.data, data);\n        if (check === 'update') Query.set(data, k || key);\n        if (check === 'warn') {\n          console.error(`Chipper: You're trying to change \"${k || key}\" data shape`);\n        }\n      } else Query.set(data, k || key);\n    },\n  };\n\n  return { data: chop?.data, status: chop?.status, api, set };\n}\n\nexport function useChipper<T = IData>(instance: ChipperConveyor, key: string, data?: T) {\n  const Query = chipperOperator<T>(instance, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport function useChip<T = IData>(key: string, data?: T) {\n  const Query = chipperOperator<T>(Chipper, key, data) as IQuery;\n  return chipperService<T>(Query, key);\n}\n\nexport { Utils };\nexport default Chipper;\n"],"names":["newChip","data","status","type","equalityCheck","chop","chip","objectKeys","o","Object","keys","sort","isEqual","JSON","stringify","chopper","update","updated","produce","__assign","mockAsync","timeout","Promise","resolve","reject","setTimeout","undefined","message","setAsync","Query","options","createAsyncGenerator","set","get","onInit","_a","runAsync","resp","Error","onError","wrapResp","onSuccess","AsyncGenerator","next","this","ChipperQueue","key","queue","push","filter","forEach","convey","_this","Map","__extends","ChipperConveyor","map","que","chips","Utils.newChip","has","k","cut","delete","console","error","Chipper","chipperOperator","chipper","query","queryQueue","dispatch","__read","React.useState","isLoading","React.useEffect","enqueue","dequeue","chipperService","api","check","Utils.equalityCheck","Utils.chopper","Utils.setAsync","mocked","Utils.mockAsync","useChipper","instance","useChip"],"mappings":"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"}